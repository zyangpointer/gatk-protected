package org.broadinstitute.hellbender.tools.exome;

import org.broadinstitute.hellbender.cmdline.*;
import org.broadinstitute.hellbender.cmdline.programgroups.CopyNumberProgramGroup;
import org.broadinstitute.hellbender.exceptions.UserException;
import org.broadinstitute.hellbender.tools.exome.allelefraction.AlleleFractionData;
import org.broadinstitute.hellbender.tools.exome.allelefraction.AlleleFractionModeller;
import org.broadinstitute.hellbender.tools.exome.allelefraction.AlleleFractionParameter;
import org.broadinstitute.hellbender.tools.exome.allelefraction.AlleleFractionState;
import org.broadinstitute.hellbender.tools.exome.alleliccount.AllelicCountCollection;
import org.broadinstitute.hellbender.tools.exome.alleliccount.AllelicCountWithPhasePosteriorsCollection;
import org.broadinstitute.hellbender.tools.exome.pulldown.PhasePosteriorsCalculator;
import org.broadinstitute.hellbender.tools.exome.pulldown.Pulldown;
import org.broadinstitute.hellbender.utils.mcmc.ParameterReader;
import org.broadinstitute.hellbender.utils.mcmc.PosteriorSummary;

import java.io.File;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Given a {@link ACNVModeledSegment} file and a file containing a {@link PosteriorSummary} for each global parameter
 * of the {@link AlleleFractionState} (both generated by fitting {@link AlleleFractionData} with an
 * {@link AlleleFractionModeller}), outputs a {@link Pulldown} that gives the probability
 * for each het to be ref minor, alt minor, or an outlier, according to the MAP model fit.
 *
 * @author Samuel Lee &lt;slee@broadinstitute.org&gt;
 */
@CommandLineProgramProperties(
        summary = "Given case-sample output generated by the GATK ACNV workflow, outputs a pulldown file giving" +
                "ref/alt counts at heterozygous SNP sites, along with the probabilities of each site being ref minor," +
                "alt minor, or an outlier, according to the allele-fraction model fit by ACNV.",
        oneLineSummary = "Output phase posteriors using allelic-count data and GATK ACNV output.",
        programGroup = CopyNumberProgramGroup.class
)
public class CalculatePulldownPhasePosteriors extends CommandLineProgram {
    private static final long serialVersionUID = 111222333l;

    //CLI arguments
    protected static final String OUTPUT_PREFIX_LONG_NAME = "outputPrefix";
    protected static final String OUTPUT_PREFIX_SHORT_NAME = "pre";

    @Argument(
            doc = "Input file for tumor-sample ref/alt read counts at normal-sample heterozygous-SNP sites (output of GetHetCoverage or GetBayesianHetCoverage tools).",
            fullName = ExomeStandardArgumentDefinitions.TUMOR_ALLELIC_COUNTS_FILE_LONG_NAME,
            shortName = ExomeStandardArgumentDefinitions.TUMOR_ALLELIC_COUNTS_FILE_SHORT_NAME,
            optional = false
    )
    protected File snpCountsFile;

    @Argument(
            doc = "Input file for GATK ACNV segments.",
            fullName = ExomeStandardArgumentDefinitions.SEGMENT_FILE_LONG_NAME,
            shortName = ExomeStandardArgumentDefinitions.SEGMENT_FILE_SHORT_NAME,
            optional = false
    )
    protected File segmentsFile;

    @Argument(
            doc = "Input file for GATK ACNV allele-fraction global parameters " +
                    "(with extension " + AllelicCNV.AF_PARAMETER_FILE_SUFFIX + ").",
            fullName = ExomeStandardArgumentDefinitions.SEGMENT_FILE_LONG_NAME,
            shortName = ExomeStandardArgumentDefinitions.SEGMENT_FILE_SHORT_NAME,
            optional = false
    )
    protected File parametersFile;

    @Argument(
            doc = "Output file",
            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,
            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME
    )
    protected File outputFile;

    @Override
    public Object doWork() {
        //read counts and state from files
        final AllelicCountCollection counts = new AllelicCountCollection(snpCountsFile);
        final AlleleFractionState state = readState(segmentsFile, parametersFile);

        //calculate phase posteriors
        final AllelicCountWithPhasePosteriorsCollection countsWithPhasePosteriors =
                new PhasePosteriorsCalculator(counts, state).calculatePhasePosteriors();

        //write phase posteriors to file with same verbosity as input file
        countsWithPhasePosteriors.write(outputFile, counts.getVerbosity());

        return "SUCCESS";
    }

    private AlleleFractionState readState(final File segmentsFile, final File parametersFile) {
        final List<ACNVModeledSegment> segments = SegmentUtils.readACNVModeledSegmentFile(segmentsFile);
        final Map<AlleleFractionParameter, PosteriorSummary> parameterMap = new LinkedHashMap<>();
        try (final ParameterReader<AlleleFractionParameter> reader = new ParameterReader<>(parametersFile, AlleleFractionParameter.class)) {
            reader.stream().forEach(p -> parameterMap.put(p.getKey(), p.getValue()));
        } catch (final IOException e) {
            throw new UserException.CouldNotReadInputFile(parametersFile);
        }
        final double meanBias = parameterMap.get(AlleleFractionParameter.MEAN_BIAS).getCenter();
        final double biasVariance = parameterMap.get(AlleleFractionParameter.BIAS_VARIANCE).getCenter();
        final double outlierProbability = parameterMap.get(AlleleFractionParameter.OUTLIER_PROBABILITY).getCenter();
        final AlleleFractionState.MinorFractions minorFractions =
                new AlleleFractionState.MinorFractions(segments.stream().map(s -> s.getMinorAlleleFractionPosteriorSummary().getCenter()).collect(Collectors.toList()));
        return new AlleleFractionState(meanBias, biasVariance, outlierProbability, minorFractions);
    }
}