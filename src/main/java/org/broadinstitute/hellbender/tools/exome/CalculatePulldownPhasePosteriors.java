package org.broadinstitute.hellbender.tools.exome;

import org.broadinstitute.hellbender.cmdline.*;
import org.broadinstitute.hellbender.cmdline.programgroups.CopyNumberProgramGroup;
import org.broadinstitute.hellbender.exceptions.UserException;
import org.broadinstitute.hellbender.tools.exome.allelefraction.*;
import org.broadinstitute.hellbender.tools.exome.alleliccount.AllelicCount;
import org.broadinstitute.hellbender.tools.exome.alleliccount.AllelicCountCollection;
import org.broadinstitute.hellbender.tools.exome.alleliccount.AllelicCountWithPhasePosteriors;
import org.broadinstitute.hellbender.tools.exome.alleliccount.AllelicCountWithPhasePosteriorsCollection;
import org.broadinstitute.hellbender.tools.exome.pulldown.Pulldown;
import org.broadinstitute.hellbender.utils.mcmc.ParameterReader;
import org.broadinstitute.hellbender.utils.mcmc.PosteriorSummary;

import java.io.File;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Given a {@link ACNVModeledSegment} file and a file containing a {@link PosteriorSummary} for each global parameter
 * of the {@link AlleleFractionState} (both generated by fitting {@link AlleleFractionData} with an
 * {@link AlleleFractionModeller}), outputs a {@link Pulldown} that gives the probability
 * for each het to be ref minor, alt minor, or an outlier, according to the MAP model fit.
 *
 * @author Samuel Lee &lt;slee@broadinstitute.org&gt;
 */
@CommandLineProgramProperties(
        summary = "Given case-sample output generated by the GATK ACNV workflow, outputs a pulldown file giving " +
                "ref/alt counts at heterozygous SNP sites, along with the probabilities of each site being ref minor, " +
                "alt minor, or an outlier, according to the allele-fraction model fit by ACNV.",
        oneLineSummary = "Output pulldown with phase posteriors using allelic-count data and GATK ACNV output.",
        programGroup = CopyNumberProgramGroup.class
)
public class CalculatePulldownPhasePosteriors extends CommandLineProgram {
    @Argument(
            doc = "Input file for tumor-sample ref/alt read counts at normal-sample heterozygous-SNP sites (output of GetHetCoverage or GetBayesianHetCoverage tools).",
            fullName = ExomeStandardArgumentDefinitions.TUMOR_ALLELIC_COUNTS_FILE_LONG_NAME,
            shortName = ExomeStandardArgumentDefinitions.TUMOR_ALLELIC_COUNTS_FILE_SHORT_NAME,
            optional = false
    )
    protected File snpCountsFile;

    @Argument(
            doc = "Input file for GATK ACNV segments.",
            fullName = ExomeStandardArgumentDefinitions.SEGMENT_FILE_LONG_NAME,
            shortName = ExomeStandardArgumentDefinitions.SEGMENT_FILE_SHORT_NAME,
            optional = false
    )
    protected File segmentsFile;

    @Argument(
            doc = "Input file for GATK ACNV allele-fraction global parameters " +
                    "(with extension " + AllelicCNV.AF_PARAMETER_FILE_SUFFIX + ").",
            fullName = ExomeStandardArgumentDefinitions.SEGMENT_FILE_LONG_NAME,
            shortName = ExomeStandardArgumentDefinitions.SEGMENT_FILE_SHORT_NAME,
            optional = false
    )
    protected File parametersFile;

    @Argument(
            doc = "Input file for allelic-bias panel of normals.",
            fullName = ExomeStandardArgumentDefinitions.ALLELIC_PON_FILE_LONG_NAME,
            shortName = ExomeStandardArgumentDefinitions.ALLELIC_PON_FILE_SHORT_NAME,
            optional = true
    )
    protected File allelicPONFile;

    @Argument(
            doc = "Output file.",
            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,
            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME
    )
    protected File outputFile;

    @Override
    public Object doWork() {
        //read counts, segments, and parameters from files
        final AllelicCountCollection counts = new AllelicCountCollection(snpCountsFile);
        final List<ACNVModeledSegment> segments = SegmentUtils.readACNVModeledSegmentFile(segmentsFile);
        final AlleleFractionState state = readState(segments, parametersFile);

        //load allelic-bias panel of normals if provided
        final AllelicPanelOfNormals allelicPON =
                allelicPONFile != null ? new AllelicPanelOfNormals(allelicPONFile) : AllelicPanelOfNormals.EMPTY_PON;

        //calculate phase posteriors
        final AllelicCountWithPhasePosteriorsCollection countsWithPhasePosteriors =
                calculatePhasePosteriors(counts, segments, state, allelicPON);

        //write phase posteriors to file with same verbosity as input file
        countsWithPhasePosteriors.write(outputFile, counts.getVerbosity());

        return "SUCCESS";
    }

    private AlleleFractionState readState(final List<ACNVModeledSegment> segments, final File parametersFile) {
        final Map<AlleleFractionParameter, PosteriorSummary> parameterMap = new LinkedHashMap<>();
        try (final ParameterReader<AlleleFractionParameter> reader = new ParameterReader<>(parametersFile, AlleleFractionParameter.class)) {
            reader.stream().forEach(p -> parameterMap.put(p.getKey(), p.getValue()));
        } catch (final IOException e) {
            throw new UserException.CouldNotReadInputFile(parametersFile);
        }
        final double meanBias = parameterMap.get(AlleleFractionParameter.MEAN_BIAS).getCenter();
        final double biasVariance = parameterMap.get(AlleleFractionParameter.BIAS_VARIANCE).getCenter();
        final double outlierProbability = parameterMap.get(AlleleFractionParameter.OUTLIER_PROBABILITY).getCenter();
        final List<Double> posteriorModeMinorFractions =
                segments.stream().map(s -> s.getMinorAlleleFractionPosteriorSummary().getCenter()).collect(Collectors.toList());
        final AlleleFractionState.MinorFractions minorFractions = new AlleleFractionState.MinorFractions(posteriorModeMinorFractions);
        return new AlleleFractionState(meanBias, biasVariance, outlierProbability, minorFractions);
    }

    private AllelicCountWithPhasePosteriorsCollection calculatePhasePosteriors(final AllelicCountCollection counts,
                                                                               final List<ACNVModeledSegment> segments,
                                                                               final AlleleFractionState state,
                                                                               final AllelicPanelOfNormals allelicPON) {
        final TargetCollection<ACNVModeledSegment> segmentTargetCollection = new HashedListTargetCollection<>(segments);
        final AllelicCountWithPhasePosteriorsCollection countsWithPhasePosteriors = new AllelicCountWithPhasePosteriorsCollection();
        for (final AllelicCount count : counts.getCounts()) {
            final int segmentIndex = segmentTargetCollection.index(count.getInterval());
            if (segmentIndex < 0) {
                throw new UserException.EmptyIntersection(String.format("The AllelicCount at %s is not located within one of the input segments.", count.getInterval()));
            }
            final double refMinorProb = AlleleFractionLikelihoods.hetLogLikelihood(state, segmentIndex, count, AlleleFractionIndicator.REF_MINOR, allelicPON);
            final double altMinorProb = AlleleFractionLikelihoods.hetLogLikelihood(state, segmentIndex, count, AlleleFractionIndicator.ALT_MINOR, allelicPON);
            final double outlierProb = AlleleFractionLikelihoods.hetLogLikelihood(state, segmentIndex, count, AlleleFractionIndicator.OUTLIER, allelicPON);
            final AllelicCountWithPhasePosteriors countWithPhasePosteriors = new AllelicCountWithPhasePosteriors(count, refMinorProb, altMinorProb, outlierProb);
            countsWithPhasePosteriors.add(countWithPhasePosteriors);
        }
        return countsWithPhasePosteriors;
    }
}